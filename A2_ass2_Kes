import os
import csv
import datetime as dt
import time
import logging
import subprocess
import sys
from math import floor, ceil
from optibook.synchronous_client import Exchange
from optibook.common_types import InstrumentType, OptionKind

# Install scipy if not available
def install_and_import(package):
    try:
        __import__(package)
    except ImportError:
        subprocess.check_call([sys.executable, "-m", "pip", "install", package])
    finally:
        globals()[package] = __import__(package)

install_and_import("scipy")

sys.path.append("/home/workspace/your_optiver_workspace")
from common.black_scholes import call_value, put_value, call_delta, put_delta
from common.libs import calculate_current_time_to_date

# Connect to the exchange
exchange = Exchange()
exchange.connect()
logging.getLogger("client").setLevel("ERROR")

# ------------------ Helper Functions ------------------ #
def round_down_to_tick(price, tick_size):
    return floor(price / tick_size) * tick_size

def round_up_to_tick(price, tick_size):
    return ceil(price / tick_size) * tick_size

def get_midpoint_value(instrument_id):
    order_book = exchange.get_last_price_book(instrument_id=instrument_id)
    if not (order_book and order_book.bids and order_book.asks):
        return None
    return (order_book.bids[0].price + order_book.asks[0].price) / 2.0

def calculate_theoretical_option_value(expiry, strike, option_kind, stock_value, interest_rate, volatility):
    time_to_expiry = calculate_current_time_to_date(expiry)
    if option_kind == OptionKind.CALL:
        return call_value(S=stock_value, K=strike, T=time_to_expiry, r=interest_rate, sigma=volatility)
    elif option_kind == OptionKind.PUT:
        return put_value(S=stock_value, K=strike, T=time_to_expiry, r=interest_rate, sigma=volatility)

def calculate_option_delta(expiry_date, strike, option_kind, stock_value, interest_rate, volatility):
    time_to_expiry = calculate_current_time_to_date(expiry_date)
    if option_kind == OptionKind.CALL:
        return call_delta(S=stock_value, K=strike, T=time_to_expiry, r=interest_rate, sigma=volatility)
    elif option_kind == OptionKind.PUT:
        return put_delta(S=stock_value, K=strike, T=time_to_expiry, r=interest_rate, sigma=volatility)
    else:
        raise Exception(f"Unexpected option_kind: {option_kind}")

def update_quotes(option_id, theoretical_price, credit, volume, position_limit, tick_size):
    # Pull outstanding orders
    orders = exchange.get_outstanding_orders(instrument_id=option_id)
    for order_id in orders:
        exchange.delete_order(instrument_id=option_id, order_id=order_id)

    bid_price = round_down_to_tick(theoretical_price - credit, tick_size)
    ask_price = round_up_to_tick(theoretical_price + credit, tick_size)

    position = exchange.get_positions()[option_id]
    max_buy = position_limit - position
    max_sell = position_limit + position
    bid_volume = min(volume, max_buy)
    ask_volume = min(volume, max_sell)

    if bid_volume > 0:
        exchange.insert_order(instrument_id=option_id, price=bid_price, volume=bid_volume, side="bid", order_type="limit")
    if ask_volume > 0:
        exchange.insert_order(instrument_id=option_id, price=ask_price, volume=ask_volume, side="ask", order_type="limit")

    return bid_price, ask_price, bid_volume, ask_volume

def hedge_delta_position(stock_id, options, stock_value):
    positions = exchange.get_positions()
    total_delta = 0.0
    for option_id, option in options.items():
        position = positions.get(option_id, 0)
        if position != 0:
            option_delta = calculate_option_delta(option.expiry, option.strike, option.option_kind, stock_value, 0.03, 3.0)
            total_delta += option_delta * position
    stock_position = positions.get(stock_id, 0)
    # Placeholder: no delta hedge implemented
    return total_delta, stock_position

def load_instruments_for_underlying(underlying_stock_id):
    all_instruments = exchange.get_instruments()
    stock = all_instruments[underlying_stock_id]
    options = {iid: inst for iid, inst in all_instruments.items() if inst.instrument_type == InstrumentType.STOCK_OPTION and inst.base_instrument_id == underlying_stock_id}
    return stock, options

# ------------------ Initialization ------------------ #
STOCK_ID = "ASML"
stock, options = load_instruments_for_underlying(STOCK_ID)

csv_file = "A2_ass2.csv"
write_header = not os.path.exists(csv_file)
csv_fields = [
    "iteration", "timestamp", "stock_value",
    "option_id", "theoretical_value", "bid_price", "ask_price",
    "bid_volume", "ask_volume", "option_position", "option_delta",
    "total_portfolio_delta", "stock_position",
    "realized_pnl", "unrealized_pnl", "delta_adjusted_pnl"
]

pnl_history = []
run = 0
start_time = dt.datetime.utcnow()

# ------------------ Main Loop ------------------ #
while True:
    run += 1
    now = dt.datetime.utcnow()

    stock_value = get_midpoint_value(STOCK_ID)
    if stock_value is None:
        print("Empty stock order book, skipping iteration.")
        time.sleep(4)
        continue

    positions = exchange.get_positions()
    total_delta, stock_position = hedge_delta_position(STOCK_ID, options, stock_value)

    with open(csv_file, mode="a", newline="") as f:
        writer = csv.DictWriter(f, fieldnames=csv_fields)
        if write_header:
            writer.writeheader()
            write_header = False

        for option_id, option in options.items():
            option_position = positions.get(option_id, 0)
            theoretical_value = calculate_theoretical_option_value(
                expiry=option.expiry,
                strike=option.strike,
                option_kind=option.option_kind,
                stock_value=stock_value,
                interest_rate=0.03,
                volatility=3.0,
            )

            bid_price, ask_price, bid_volume, ask_volume = update_quotes(
                option_id=option_id,
                theoretical_price=theoretical_value,
                credit=0.15,
                volume=3,
                position_limit=100,
                tick_size=0.10
            )

            option_delta = calculate_option_delta(
                expiry_date=option.expiry,
                strike=option.strike,
                option_kind=option.option_kind,
                stock_value=stock_value,
                interest_rate=0.03,
                volatility=3.0,
            )

            # Placeholder PnL calculations (could be improved with actual trades)
            realized_pnl = 0.0
            unrealized_pnl = option_position * (stock_value - theoretical_value)  # rough approximation
            delta_adjusted_pnl = unrealized_pnl - total_delta * stock_value  # rough hedge adjustment

            writer.writerow({
                "iteration": run,
                "timestamp": now.strftime("%Y-%m-%d %H:%M:%S"),
                "stock_value": stock_value,
                "option_id": option_id,
                "theoretical_value": theoretical_value,
                "bid_price": bid_price,
                "ask_price": ask_price,
                "bid_volume": bid_volume,
                "ask_volume": ask_volume,
                "option_position": option_position,
                "option_delta": option_delta,
                "total_portfolio_delta": total_delta,
                "stock_position": stock_position,
                "realized_pnl": realized_pnl,
                "unrealized_pnl": unrealized_pnl,
                "delta_adjusted_pnl": delta_adjusted_pnl
            })
        f.flush()

    print(f"Iteration {run} completed. Sleeping for 4 seconds.")
    time.sleep(4)
