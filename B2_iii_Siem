import csv
import math
import time
import logging
import statistics as stats
import datetime as dt
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
from optibook.synchronous_client import Exchange

RISK_FREE_RATE = 0.03
THRESHOLD = 0.2
SIZE_PER_UNIT = 50                    
STOCK_ID = "ASML"
FUT_ID = "ASML_202512_F"
EXPIRY = dt.datetime(2025, 12, 31)

START_FLATTEN = True
FLATTEN_ON_INTERRUPT = False

OUT_CSV = "pnl_series.csv"
OUT_PNG = "pnl_series.png"


exchange = Exchange()
exchange.connect()
logging.getLogger("client").setLevel("ERROR")

pnl_series = []
adj_pnl_series = []
baseline_pnl = None

def print_positions_and_pnl(always_display=None):
    positions = exchange.get_positions()
    print("Positions:")
    for instrument_id, q in positions.items():
        if (not always_display) or (instrument_id in always_display) or (q != 0):
            print(f"  {instrument_id:20s}: {q:4.0f}")
    pnl = exchange.get_pnl()
    if pnl is not None:
        print(f"\nPnL: {pnl:.2f}")

def write_report():
    if not adj_pnl_series:
        print("No PnL observations to plot.")
        return
    with open(OUT_CSV, "w", newline="") as f:
        w = csv.writer(f)
        w.writerow(["i", "AdjPnL", "RawPnL"])
        for i, adj in enumerate(adj_pnl_series, start=1):
            raw = pnl_series[i-1] if i-1 < len(pnl_series) else ""
            w.writerow([i, adj, raw])

    plt.figure(figsize=(9,5))
    plt.plot(adj_pnl_series)
    plt.title("Adjusted PnL (baseline at first observation)")
    plt.xlabel("Iteration")
    plt.ylabel("AdjPnL")
    plt.grid(True)
    plt.savefig(OUT_PNG, dpi=150, bbox_inches="tight")

    mean_adj = stats.mean(adj_pnl_series)
    stdev_adj = stats.pstdev(adj_pnl_series) if len(adj_pnl_series) > 1 else 0.0
    print(f"Saved: {OUT_CSV}, {OUT_PNG}")
    print(f"AdjPnL mean: {mean_adj:+.3f}, stdev: {stdev_adj:.3f}")

def get_mid_price(order_book):
    if order_book and order_book.bids and order_book.asks:
        best_bid = order_book.bids[0].price
        best_ask = order_book.asks[0].price
        return (best_bid + best_ask) / 2.0
    return None

def max_lots_allowed(instrument_id, side, position_limit=100):
    positions = exchange.get_positions()
    current_pos = int(positions.get(instrument_id, 0))
    if side == "bid":    
        return max(position_limit - current_pos, 0)
    else:                
        return max(position_limit + current_pos, 0)

def flatten_all():
    positions = exchange.get_positions()
    for instrument_id, q in list(positions.items()):
        if q == 0:
            continue
        book = exchange.get_last_price_book(instrument_id)
        if not (book and book.bids and book.asks):
            continue
        side = "ask" if q > 0 else "bid"
        price = (book.bids[0].price if side == "ask"
                 else book.asks[0].price)
        try:
            exchange.insert_order(instrument_id, price=price, volume=abs(int(q)),
                                  side=side, order_type="ioc")
        except Exception as e:
            print(f"Flatten error on {instrument_id}: {e}")

if START_FLATTEN:
    flatten_all()
    time.sleep(0.25)

try:
    while True:
        print("")
        print("-----------------------------------------------------------------")
        print(f"TRADE LOOP ITERATION ENTERED AT {str(dt.datetime.utcnow()):18s} UTC.")
        print("-----------------------------------------------------------------")
        print_positions_and_pnl()
        print("")

        stock_book = exchange.get_last_price_book(STOCK_ID)
        future_book = exchange.get_last_price_book(FUT_ID)
        spot_price = get_mid_price(stock_book)
        future_price = get_mid_price(future_book)

        if not spot_price or not future_price:
            print("No prices available, skipping iteration.")
            time.sleep(1)
            continue

        now = dt.datetime.utcnow()
        T = (EXPIRY - now).days / 365.0
        F_theoretical = spot_price * math.exp(RISK_FREE_RATE * T)  
        mispricing = future_price - F_theoretical

        positions = exchange.get_positions()
        delta_now = int(positions.get(FUT_ID,0)) + int(positions.get(STOCK_ID,0))
        print(f"Spot: {spot_price:.2f}, Fut: {future_price:.2f}, "
              f"F_theo: {F_theoretical:.2f}, mispricing: {mispricing:+.4f}, "
              f"T(days)={(EXPIRY - now).days}, Î”={delta_now:+.2f}")

        if abs(mispricing) > THRESHOLD:
            desired_lots = max(1, int(abs(mispricing) * SIZE_PER_UNIT))

            if mispricing > 0:
                lots_stock = min(desired_lots, max_lots_allowed(STOCK_ID, "bid"))
                lots_fut   = min(desired_lots, max_lots_allowed(FUT_ID,  "ask"))
                lots = min(lots_stock, lots_fut)
                if lots > 0:
                    try:
                        exchange.insert_order(STOCK_ID, price=stock_book.asks[0].price,
                                              volume=lots, side="bid", order_type="ioc")
                        exchange.insert_order(FUT_ID,   price=future_book.bids[0].price,
                                              volume=lots, side="ask", order_type="ioc")
                        print(f"Opened {lots} lots: BUY stock, SELL future")
                    except Exception as e:
                        print(f"Open error: {e}")

            else:
                lots_fut   = min(desired_lots, max_lots_allowed(FUT_ID,  "bid"))
                lots_stock = min(desired_lots, max_lots_allowed(STOCK_ID, "ask"))
                lots = min(lots_fut, lots_stock)
                if lots > 0:
                    try:
                        exchange.insert_order(FUT_ID,   price=future_book.asks[0].price,
                                              volume=lots, side="bid", order_type="ioc")
                        exchange.insert_order(STOCK_ID, price=stock_book.bids[0].price,
                                              volume=lots, side="ask", order_type="ioc")
                        print(f"Opened {lots} lots: SELL stock, BUY future")
                    except Exception as e:
                        print(f"Open error: {e}")
            while True:
                pos = exchange.get_positions()
                stock_pos = int(pos.get(STOCK_ID, 0))
                fut_pos   = int(pos.get(FUT_ID,   0))
                hedge_diff = stock_pos + fut_pos  

                if hedge_diff == 0:
                    print("Stock and futures positions are correctly hedged.")
                    break

                try:
                    if hedge_diff > 0:
                        max_sell = max_lots_allowed(STOCK_ID, "ask")
                        vol = min(hedge_diff, max_sell)
                        if vol == 0: 
                            print("Cannot sell more stock due to position limits.")
                            break
                        exchange.insert_order(STOCK_ID, price=stock_book.bids[0].price,
                                              volume=vol, side="ask", order_type="ioc")
                        print(f"Hedge adjustment: SOLD {vol} stock to reduce net exposure")
                    else:
                        max_buy = max_lots_allowed(STOCK_ID, "bid")
                        vol = min(-hedge_diff, max_buy)
                        if vol == 0:
                            print("Cannot buy more stock due to position limits.")
                            break
                        exchange.insert_order(STOCK_ID, price=stock_book.asks[0].price,
                                              volume=vol, side="bid", order_type="ioc")
                        print(f"Hedge adjustment: BOUGHT {vol} stock to reduce net exposure")
                except Exception as e:
                    print(f"Hedge error: {e}")
                    break

                time.sleep(0.1)

        else:
            print("No significant mispricing. Waiting for next opportunity.")

        pnl = exchange.get_pnl()
        if pnl is not None:
            if baseline_pnl is None:
                baseline_pnl = float(pnl)
            pnl_series.append(float(pnl))
            adj = float(pnl) - baseline_pnl
            adj_pnl_series.append(adj)
            print(f"AdjPnL={adj:+.2f}")

        time.sleep(1)

except KeyboardInterrupt:
    if FLATTEN_ON_INTERRUPT:
        flatten_all()
    write_report()
