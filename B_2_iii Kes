
#%%
import datetime as dt
import time
import math
import logging

from optibook.synchronous_client import Exchange

RISK_FREE_RATE = 0.02 
THRESHOLD = 0.2 

exchange = Exchange()
exchange.connect()

logging.getLogger("client").setLevel("ERROR")


def trade_would_breach_position_limit(instrument_id, volume, side, position_limit=100):
    positions = exchange.get_positions()
    position_instrument = positions[instrument_id]
    if volume == 0:
        return True
    if side == "bid":
        return position_instrument + volume > position_limit
    elif side == "ask":
        return position_instrument - volume < -position_limit
    else:
        raise Exception(f"""Invalid side provided: {side}, expecting 'bid' or 'ask'.""")


def print_positions_and_pnl(always_display=None):
    positions = exchange.get_positions()
    
    print("Positions:")
    for instrument_id in positions:
        if (
            not always_display
            or instrument_id in always_display
            or positions[instrument_id] != 0
        ):
            print(f"  {instrument_id:20s}: {positions[instrument_id]:4.0f}")

    pnl = exchange.get_pnl()
    if pnl:
        print(f"\nPnL: {pnl:.2f}")


def get_mid_price(order_book):
    if order_book and order_book.bids and order_book.asks:
        best_bid = order_book.bids[0].price
        best_ask = order_book.asks[0].price
        return (best_bid + best_ask) / 2.0
    return None

def max_lots_allowed(instrument_id, side, position_limit=100):
    positions = exchange.get_positions()
    current_pos = positions.get(instrument_id, 0)
    if side == "bid":  # buying
        return max(position_limit - current_pos, 0)
    else:  # selling
        return max(position_limit + current_pos, 0)
    #%%
    print_positions_and_pnl()
#%%
while True:
    print(f"")
    print(f"-----------------------------------------------------------------")
    print(f"TRADE LOOP ITERATION ENTERED AT {str(dt.datetime.now()):18s} UTC.")
    print(f"-----------------------------------------------------------------")
    positions = exchange.get_positions()
    print_positions_and_pnl()
    print(f"")

    stock_book = exchange.get_last_price_book("ASML")
    future_book = exchange.get_last_price_book("ASML_202512_F")

    spot_price = get_mid_price(stock_book)
    future_price = get_mid_price(future_book)

    if not spot_price or not future_price:
        print("No prices available, skipping iteration.")
        time.sleep(1)
        continue

    now = dt.datetime.utcnow()
    maturity = dt.datetime(2025, 12, 31)
    T = (maturity - now).days / 365.0

    # Theoretical futures price
    F_theoretical = spot_price * math.exp((RISK_FREE_RATE) * T)

    print(f"Spot Price: {spot_price:.2f}, Futures Price: {future_price:.2f}, Theoretical F: {F_theoretical:.2f}")
    
    mispricing = future_price - F_theoretical

    if abs(mispricing) > THRESHOLD:
        # Determine desired lots based on mispricing
        desired_lots = max(1, int(abs(mispricing) * 50))  # scaling factor
        if mispricing > 0:
            # Futures overpriced -> SELL future, BUY stock
            lots_to_buy_stock = min(desired_lots, max_lots_allowed("ASML", "bid"))
            lots_to_sell_future = min(desired_lots, max_lots_allowed("ASML_202512_F", "ask"))
            lots_to_trade = min(lots_to_buy_stock, lots_to_sell_future)
            if lots_to_trade > 0:
                exchange.insert_order("ASML", price=stock_book.asks[0].price,
                                      volume=lots_to_trade, side="bid", order_type="ioc")
                exchange.insert_order("ASML_202512_F", price=future_book.bids[0].price,
                                      volume=lots_to_trade, side="ask", order_type="ioc")
                print(f"Opened {lots_to_trade} lots: BUY stock, SELL future")

        elif mispricing < 0:
            # Futures underpriced -> BUY future, SELL stock
            lots_to_buy_future = min(desired_lots, max_lots_allowed("ASML_202512_F", "bid"))
            lots_to_sell_stock = min(desired_lots, max_lots_allowed("ASML", "ask"))
            lots_to_trade = min(lots_to_buy_future, lots_to_sell_stock)
            if lots_to_trade > 0:
                exchange.insert_order("ASML_202512_F", price=future_book.asks[0].price,
                                      volume=lots_to_trade, side="bid", order_type="ioc")
                exchange.insert_order("ASML", price=stock_book.bids[0].price,
                                      volume=lots_to_trade, side="ask", order_type="ioc")
                print(f"Opened {lots_to_trade} lots: SELL stock, BUY future")

    else:
        print("No significant mispricing. Waiting for next opportunity.")

    time.sleep(1)


#%%
